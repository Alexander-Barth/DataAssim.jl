var documenterSearchIndex = {"docs":
[{"location":"#DataAssim.jl","page":"DataAssim.jl","title":"DataAssim.jl","text":"","category":"section"},{"location":"","page":"DataAssim.jl","title":"DataAssim.jl","text":"Documentation for DataAssim.jl","category":"page"},{"location":"#Simulation-driver","page":"DataAssim.jl","title":"Simulation driver","text":"","category":"section"},{"location":"","page":"DataAssim.jl","title":"DataAssim.jl","text":"The observations yo are provided as a vector of vectors (possibly of different length). Similarily their error covariance R is a vector of matrices. The elements of the vectors yo and R can be constructed as needed by the type DataAssim.VectorFun from a function:","category":"page"},{"location":"","page":"DataAssim.jl","title":"DataAssim.jl","text":"using DataAssim, LinearAlgebra\nfun = n -> (n < 5 : Matrix(I,3,3) : Matrix(I,5,5))\nR = DataAssim.VectorFun(Matrix{Bool},10,fun)","category":"page"},{"location":"","page":"DataAssim.jl","title":"DataAssim.jl","text":"where Matrix{Bool} is the return type of the function fun which can be used for n from 1 to 10 in this example.","category":"page"},{"location":"","page":"DataAssim.jl","title":"DataAssim.jl","text":"The model â„³ implementes the following API:","category":"page"},{"location":"","page":"DataAssim.jl","title":"DataAssim.jl","text":"â„³(nx) apply the model to x to forecast the index state vector. n is the time index.\ntgl(â„³nxÎ”x) apply the tangent linear model for a perturbation Î”x around x (foreward differentiation).\nadj(â„³nxÎ”x) apply the adjoin model (reverse differentiation).","category":"page"},{"location":"","page":"DataAssim.jl","title":"DataAssim.jl","text":"For any x, Î”xâ‚, Î”xâ‚‚ and n, tangent linear and adjoint model are related by:","category":"page"},{"location":"","page":"DataAssim.jl","title":"DataAssim.jl","text":"Î”xâ‚‚  tgl(â„³nxÎ”xâ‚) = adj(â„³nxÎ”xâ‚‚)  Î”xâ‚","category":"page"},{"location":"","page":"DataAssim.jl","title":"DataAssim.jl","text":"where â‹… is the inner product.","category":"page"},{"location":"","page":"DataAssim.jl","title":"DataAssim.jl","text":"The same API should also be implemented for the observation ð“— where ð“—(nx) represents the observed part of the state vector (for 4D-Var). Note that for the Kalman Filter method the adjoint (of the model or the observation operator) is not needed.","category":"page"},{"location":"","page":"DataAssim.jl","title":"DataAssim.jl","text":"For the ensemble analysis methods, only the application of the model and observations operator to every ensemble member is needed.","category":"page"},{"location":"#DataAssim.FreeRun","page":"DataAssim.jl","title":"DataAssim.FreeRun","text":"x,Hx = FreeRun(â„³,xi,Q,H,nmax,no)\n\nPerforms a free-run with the model â„³ and nmax time-steps starting at the initial condition xi. Observations at the time steps given in no are extracted with the observation operator H.\n\n\n\n\n\n","category":"function"},{"location":"#DataAssim.KalmanFilter","page":"DataAssim.jl","title":"DataAssim.KalmanFilter","text":"x,P = KalmanFilter(xi,Pi,â„³,Q,yo,R,ð“—,nmax,no)\n\nKalman Filter with the model â„³ and nmax time-steps starting at the initial condition xi and error covariance Pi. Observations yo (and error covariance R) at the time steps given in no are assimilated with the observation operator H.\n\n\n\n\n\n","category":"function"},{"location":"#DataAssim.fourDVar","page":"DataAssim.jl","title":"DataAssim.fourDVar","text":"x,J = fourDVar(\n        xi,Pi,â„³,yo,R,H,nmax,no;\n        innerloops = 10,\n        outerloops = 2,\n        tol = 1e-5)\n\nIncremental 4D-Var with the model â„³ (AbstractModel) and nmax time-steps starting at the initial condition xi and error covariance Pi with the specified numbers of inner and outer loops. Observations yo (vector of vectors) and error covariance R (vector of matrices) at the time steps given in no are assimilated with the observation operator H (AbstractModel).\n\n\n\n\n\n","category":"function"},{"location":"#Ensemble-methods","page":"DataAssim.jl","title":"Ensemble methods","text":"","category":"section"},{"location":"#DataAssim.ETKF","page":"DataAssim.jl","title":"DataAssim.ETKF","text":"Xa,xa = ETKF(Xf,HXf,y,R,H,...)\n\nComputes analysis ensemble Xa based on forecast ensemble Xf and observations y using the ETKF ensemble scheme.\n\nInput arguments:\n\nXf: forecast ensemble (n x N)\nHXf: the observation operator applied on the ensemble (product H*Xf)\ny: observations (m)\nR: observation error covariance  (m x m).\nH: operator (m x n). Except for the serialEnSRF it is never used and can be empty\n\nOptional keywords arguments:\n\ndebug: set to true to enable debugging. Default (false) is no debugging.\ntolerance: expected rounding error (default 1e-10) for debugging checks. This is not used if debug is false.\n\nOutput arguments:\n\nXa: the analysis ensemble (n x N)\nxa: the analysis ensemble mean (n)\n\nNotations follows: Sangoma D3.1 http://data-assimilation.net/Documents/sangomaDL3.1.pdf\n\n\n\n\n\n","category":"function"},{"location":"#DataAssim.EnKF","page":"DataAssim.jl","title":"DataAssim.EnKF","text":"Xa,xa = EnKF(Xf,HXf,y,R,H,...)\n\nComputes analysis ensemble Xa based on forecast ensemble Xf and observations y using the EnKF ensemble scheme.\n\nInput arguments:\n\nXf: forecast ensemble (n x N)\nHXf: the observation operator applied on the ensemble (product H*Xf)\ny: observations (m)\nR: observation error covariance  (m x m).\nH: operator (m x n). Except for the serialEnSRF it is never used and can be empty\n\nOptional keywords arguments:\n\ndebug: set to true to enable debugging. Default (false) is no debugging.\ntolerance: expected rounding error (default 1e-10) for debugging checks. This is not used if debug is false.\n\nOutput arguments:\n\nXa: the analysis ensemble (n x N)\nxa: the analysis ensemble mean (n)\n\nNotations follows: Sangoma D3.1 http://data-assimilation.net/Documents/sangomaDL3.1.pdf\n\n\n\n\n\n","category":"function"},{"location":"#DataAssim.EnSRF","page":"DataAssim.jl","title":"DataAssim.EnSRF","text":"Xa,xa = EnSRF(Xf,HXf,y,R,H,...)\n\nComputes analysis ensemble Xa based on forecast ensemble Xf and observations y using the EnSRF ensemble scheme.\n\nInput arguments:\n\nXf: forecast ensemble (n x N)\nHXf: the observation operator applied on the ensemble (product H*Xf)\ny: observations (m)\nR: observation error covariance  (m x m).\nH: operator (m x n). Except for the serialEnSRF it is never used and can be empty\n\nOptional keywords arguments:\n\ndebug: set to true to enable debugging. Default (false) is no debugging.\ntolerance: expected rounding error (default 1e-10) for debugging checks. This is not used if debug is false.\n\nOutput arguments:\n\nXa: the analysis ensemble (n x N)\nxa: the analysis ensemble mean (n)\n\nNotations follows: Sangoma D3.1 http://data-assimilation.net/Documents/sangomaDL3.1.pdf\n\n\n\n\n\n","category":"function"},{"location":"#DataAssim.EAKF","page":"DataAssim.jl","title":"DataAssim.EAKF","text":"Xa,xa = EAKF(Xf,HXf,y,R,H,...)\n\nComputes analysis ensemble Xa based on forecast ensemble Xf and observations y using the EAKF ensemble scheme.\n\nInput arguments:\n\nXf: forecast ensemble (n x N)\nHXf: the observation operator applied on the ensemble (product H*Xf)\ny: observations (m)\nR: observation error covariance  (m x m).\nH: operator (m x n). Except for the serialEnSRF it is never used and can be empty\n\nOptional keywords arguments:\n\ndebug: set to true to enable debugging. Default (false) is no debugging.\ntolerance: expected rounding error (default 1e-10) for debugging checks. This is not used if debug is false.\n\nOutput arguments:\n\nXa: the analysis ensemble (n x N)\nxa: the analysis ensemble mean (n)\n\nNotations follows: Sangoma D3.1 http://data-assimilation.net/Documents/sangomaDL3.1.pdf\n\n\n\n\n\n","category":"function"},{"location":"#DataAssim.SEIK","page":"DataAssim.jl","title":"DataAssim.SEIK","text":"Xa,xa = SEIK(Xf,HXf,y,R,H,...)\n\nComputes analysis ensemble Xa based on forecast ensemble Xf and observations y using the SEIK ensemble scheme.\n\nInput arguments:\n\nXf: forecast ensemble (n x N)\nHXf: the observation operator applied on the ensemble (product H*Xf)\ny: observations (m)\nR: observation error covariance  (m x m).\nH: operator (m x n). Except for the serialEnSRF it is never used and can be empty\n\nOptional keywords arguments:\n\ndebug: set to true to enable debugging. Default (false) is no debugging.\ntolerance: expected rounding error (default 1e-10) for debugging checks. This is not used if debug is false.\n\nOutput arguments:\n\nXa: the analysis ensemble (n x N)\nxa: the analysis ensemble mean (n)\n\nNotations follows: Sangoma D3.1 http://data-assimilation.net/Documents/sangomaDL3.1.pdf\n\n\n\n\n\n","category":"function"},{"location":"#DataAssim.ESTKF","page":"DataAssim.jl","title":"DataAssim.ESTKF","text":"Xa,xa = ESTKF(Xf,HXf,y,R,H,...)\n\nComputes analysis ensemble Xa based on forecast ensemble Xf and observations y using the ESTKF ensemble scheme.\n\nInput arguments:\n\nXf: forecast ensemble (n x N)\nHXf: the observation operator applied on the ensemble (product H*Xf)\ny: observations (m)\nR: observation error covariance  (m x m).\nH: operator (m x n). Except for the serialEnSRF it is never used and can be empty\n\nOptional keywords arguments:\n\ndebug: set to true to enable debugging. Default (false) is no debugging.\ntolerance: expected rounding error (default 1e-10) for debugging checks. This is not used if debug is false.\n\nOutput arguments:\n\nXa: the analysis ensemble (n x N)\nxa: the analysis ensemble mean (n)\n\nNotations follows: Sangoma D3.1 http://data-assimilation.net/Documents/sangomaDL3.1.pdf\n\n\n\n\n\n","category":"function"},{"location":"#DataAssim.serialEnSRF","page":"DataAssim.jl","title":"DataAssim.serialEnSRF","text":"Xa,xa = serialEnSRF(Xf,HXf,y,R,H,...)\n\nComputes analysis ensemble Xa based on forecast ensemble Xf and observations y using the serialEnSRF ensemble scheme.\n\nInput arguments:\n\nXf: forecast ensemble (n x N)\nHXf: the observation operator applied on the ensemble (product H*Xf)\ny: observations (m)\nR: observation error covariance  (m x m).\nH: operator (m x n). Except for the serialEnSRF it is never used and can be empty\n\nOptional keywords arguments:\n\ndebug: set to true to enable debugging. Default (false) is no debugging.\ntolerance: expected rounding error (default 1e-10) for debugging checks. This is not used if debug is false.\n\nOutput arguments:\n\nXa: the analysis ensemble (n x N)\nxa: the analysis ensemble mean (n)\n\nNotations follows: Sangoma D3.1 http://data-assimilation.net/Documents/sangomaDL3.1.pdf\n\n\n\n\n\n","category":"function"},{"location":"#DataAssim.local_ETKF","page":"DataAssim.jl","title":"DataAssim.local_ETKF","text":"Xa,xa = local_ETKF(Xf,H,y,diagR,part,selectObs,...)\n\nComputes analysis ensemble Xa based on forecast ensemble Xf using the observation y using the local ETKF.\n\nInputs:\n\nXf: forecast ensemble (n x N)\nH: observation operator (m x n)\ny: observation (m x 1)\ndiagR: diagonal of the observation error covariance R (m x 1)\npart: vector of integer \"labels\". Every element of the state vector with the same number belong to the same subdomain\nselectObs: callback routine to select observations with a within a subdomain. As input is takes an integer representing the index of the state vector and returns a vector of weights (m x 1). For example:\n\n     selectObs(i) = exp(- ((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2)/L^2 );\n\nor\n\n     selectObs(i) = compact_locfun(L,\n         sqrt((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2));\n\nwhere x and y is the horizontal model grid, xobs and yobs are the locations of the observations and L is a correlation length-scale\n\nOptional inputs:\n\ndisplay: if true, then display progress (false is the default)\nminweight: analysis is performed using observations for which  weights is larger than minweight. (default 1e-8)\nHXf: if non empty, then it is the product H*Xf. In this case, H is not  used\n\nOutput:\n\nXa: the analysis ensemble (n x N)\nxa`: the analysis ensemble mean (n x 1)\n\nSee also: compact_locfun\n\n\n\n\n\n","category":"function"},{"location":"#DataAssim.local_EnKF","page":"DataAssim.jl","title":"DataAssim.local_EnKF","text":"Xa,xa = local_EnKF(Xf,H,y,diagR,part,selectObs,...)\n\nComputes analysis ensemble Xa based on forecast ensemble Xf using the observation y using the local EnKF.\n\nInputs:\n\nXf: forecast ensemble (n x N)\nH: observation operator (m x n)\ny: observation (m x 1)\ndiagR: diagonal of the observation error covariance R (m x 1)\npart: vector of integer \"labels\". Every element of the state vector with the same number belong to the same subdomain\nselectObs: callback routine to select observations with a within a subdomain. As input is takes an integer representing the index of the state vector and returns a vector of weights (m x 1). For example:\n\n     selectObs(i) = exp(- ((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2)/L^2 );\n\nor\n\n     selectObs(i) = compact_locfun(L,\n         sqrt((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2));\n\nwhere x and y is the horizontal model grid, xobs and yobs are the locations of the observations and L is a correlation length-scale\n\nOptional inputs:\n\ndisplay: if true, then display progress (false is the default)\nminweight: analysis is performed using observations for which  weights is larger than minweight. (default 1e-8)\nHXf: if non empty, then it is the product H*Xf. In this case, H is not  used\n\nOutput:\n\nXa: the analysis ensemble (n x N)\nxa`: the analysis ensemble mean (n x 1)\n\nSee also: compact_locfun\n\n\n\n\n\n","category":"function"},{"location":"#DataAssim.local_EnSRF","page":"DataAssim.jl","title":"DataAssim.local_EnSRF","text":"Xa,xa = local_EnSRF(Xf,H,y,diagR,part,selectObs,...)\n\nComputes analysis ensemble Xa based on forecast ensemble Xf using the observation y using the local EnSRF.\n\nInputs:\n\nXf: forecast ensemble (n x N)\nH: observation operator (m x n)\ny: observation (m x 1)\ndiagR: diagonal of the observation error covariance R (m x 1)\npart: vector of integer \"labels\". Every element of the state vector with the same number belong to the same subdomain\nselectObs: callback routine to select observations with a within a subdomain. As input is takes an integer representing the index of the state vector and returns a vector of weights (m x 1). For example:\n\n     selectObs(i) = exp(- ((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2)/L^2 );\n\nor\n\n     selectObs(i) = compact_locfun(L,\n         sqrt((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2));\n\nwhere x and y is the horizontal model grid, xobs and yobs are the locations of the observations and L is a correlation length-scale\n\nOptional inputs:\n\ndisplay: if true, then display progress (false is the default)\nminweight: analysis is performed using observations for which  weights is larger than minweight. (default 1e-8)\nHXf: if non empty, then it is the product H*Xf. In this case, H is not  used\n\nOutput:\n\nXa: the analysis ensemble (n x N)\nxa`: the analysis ensemble mean (n x 1)\n\nSee also: compact_locfun\n\n\n\n\n\n","category":"function"},{"location":"#DataAssim.local_EAKF","page":"DataAssim.jl","title":"DataAssim.local_EAKF","text":"Xa,xa = local_EAKF(Xf,H,y,diagR,part,selectObs,...)\n\nComputes analysis ensemble Xa based on forecast ensemble Xf using the observation y using the local EAKF.\n\nInputs:\n\nXf: forecast ensemble (n x N)\nH: observation operator (m x n)\ny: observation (m x 1)\ndiagR: diagonal of the observation error covariance R (m x 1)\npart: vector of integer \"labels\". Every element of the state vector with the same number belong to the same subdomain\nselectObs: callback routine to select observations with a within a subdomain. As input is takes an integer representing the index of the state vector and returns a vector of weights (m x 1). For example:\n\n     selectObs(i) = exp(- ((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2)/L^2 );\n\nor\n\n     selectObs(i) = compact_locfun(L,\n         sqrt((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2));\n\nwhere x and y is the horizontal model grid, xobs and yobs are the locations of the observations and L is a correlation length-scale\n\nOptional inputs:\n\ndisplay: if true, then display progress (false is the default)\nminweight: analysis is performed using observations for which  weights is larger than minweight. (default 1e-8)\nHXf: if non empty, then it is the product H*Xf. In this case, H is not  used\n\nOutput:\n\nXa: the analysis ensemble (n x N)\nxa`: the analysis ensemble mean (n x 1)\n\nSee also: compact_locfun\n\n\n\n\n\n","category":"function"},{"location":"#DataAssim.local_SEIK","page":"DataAssim.jl","title":"DataAssim.local_SEIK","text":"Xa,xa = local_SEIK(Xf,H,y,diagR,part,selectObs,...)\n\nComputes analysis ensemble Xa based on forecast ensemble Xf using the observation y using the local SEIK.\n\nInputs:\n\nXf: forecast ensemble (n x N)\nH: observation operator (m x n)\ny: observation (m x 1)\ndiagR: diagonal of the observation error covariance R (m x 1)\npart: vector of integer \"labels\". Every element of the state vector with the same number belong to the same subdomain\nselectObs: callback routine to select observations with a within a subdomain. As input is takes an integer representing the index of the state vector and returns a vector of weights (m x 1). For example:\n\n     selectObs(i) = exp(- ((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2)/L^2 );\n\nor\n\n     selectObs(i) = compact_locfun(L,\n         sqrt((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2));\n\nwhere x and y is the horizontal model grid, xobs and yobs are the locations of the observations and L is a correlation length-scale\n\nOptional inputs:\n\ndisplay: if true, then display progress (false is the default)\nminweight: analysis is performed using observations for which  weights is larger than minweight. (default 1e-8)\nHXf: if non empty, then it is the product H*Xf. In this case, H is not  used\n\nOutput:\n\nXa: the analysis ensemble (n x N)\nxa`: the analysis ensemble mean (n x 1)\n\nSee also: compact_locfun\n\n\n\n\n\n","category":"function"},{"location":"#DataAssim.local_ESTKF","page":"DataAssim.jl","title":"DataAssim.local_ESTKF","text":"Xa,xa = local_ESTKF(Xf,H,y,diagR,part,selectObs,...)\n\nComputes analysis ensemble Xa based on forecast ensemble Xf using the observation y using the local ESTKF.\n\nInputs:\n\nXf: forecast ensemble (n x N)\nH: observation operator (m x n)\ny: observation (m x 1)\ndiagR: diagonal of the observation error covariance R (m x 1)\npart: vector of integer \"labels\". Every element of the state vector with the same number belong to the same subdomain\nselectObs: callback routine to select observations with a within a subdomain. As input is takes an integer representing the index of the state vector and returns a vector of weights (m x 1). For example:\n\n     selectObs(i) = exp(- ((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2)/L^2 );\n\nor\n\n     selectObs(i) = compact_locfun(L,\n         sqrt((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2));\n\nwhere x and y is the horizontal model grid, xobs and yobs are the locations of the observations and L is a correlation length-scale\n\nOptional inputs:\n\ndisplay: if true, then display progress (false is the default)\nminweight: analysis is performed using observations for which  weights is larger than minweight. (default 1e-8)\nHXf: if non empty, then it is the product H*Xf. In this case, H is not  used\n\nOutput:\n\nXa: the analysis ensemble (n x N)\nxa`: the analysis ensemble mean (n x 1)\n\nSee also: compact_locfun\n\n\n\n\n\n","category":"function"},{"location":"#Models","page":"DataAssim.jl","title":"Models","text":"","category":"section"},{"location":"#DataAssim.AbstractModel","page":"DataAssim.jl","title":"DataAssim.AbstractModel","text":"Abstract base-class of models. A model should implement forecast step, tangent-linear and adjoint step\n\n\n\n\n\n","category":"type"},{"location":"#DataAssim.ModelMatrix","page":"DataAssim.jl","title":"DataAssim.ModelMatrix","text":"â„³ = ModelMatrix(M)\n\nLinear model defined by the matrix M.\n\n\n\n\n\n","category":"type"},{"location":"#DataAssim.ModelFun","page":"DataAssim.jl","title":"DataAssim.ModelFun","text":"â„³ = ModelFun(nonlinear_forecast,tangent_linear_model,adjoint_model)\n\nModel defined by the functions nonlinear_forecast,tangent_linear_model and  adjoint_model.\n\n\n\n\n\n","category":"type"},{"location":"#DataAssim.LinShallowWater1DModel","page":"DataAssim.jl","title":"DataAssim.LinShallowWater1DModel","text":"â„³ = LinShallowWater1DModel(dt,g,h,L,imax)\n\nLinear 1D shallow water model.\n\nExample\n\ndt = 1.\ng = 9.81\nh = 100\nimax = 101\nL = 10000\nLinShallowWater1DModel(dt,g,h,L,imax)\n\n\n\n\n\n","category":"type"},{"location":"#DataAssim.Lorenz63Model","page":"DataAssim.jl","title":"DataAssim.Lorenz63Model","text":"â„³ = Lorenz63Model(dt,Ïƒ=10.,Î² = 8/3.,Ï = 28.)\n\nLorenz, 1963 model[1] integrated with a 2nd order Runge-Kutta scheme.\n\n[1] https://doi.org/10.1175/1520-0469(1963)020%3C0130:DNF%3E2.0.CO;2\n\n\n\n\n\n","category":"type"},{"location":"#Utility-functions","page":"DataAssim.jl","title":"Utility functions","text":"","category":"section"},{"location":"#DataAssim.compact_locfun","page":"DataAssim.jl","title":"DataAssim.compact_locfun","text":" fun = compact_locfun(r)\n\nSmooth compact localization function at the (scaled) distance r. fun is zero if r > 2 and one if r is 0. (Gaspari et al. (1999), equation 4.10, [1])\n\n[1] http://dx.doi.org/10.1002/qj.49712555417\n\n\n\n\n\n","category":"function"},{"location":"#DataAssim.talagrand_diagram","page":"DataAssim.jl","title":"DataAssim.talagrand_diagram","text":"freq = talagrand_diagram(x,y)\n\nCompute the frequency of each bins for a Talagrand Diagram where x is the ensemble (array of the size sample Ã— ensemble size) and y are the obervations (sample).\n\nA U-shaped diagram means that the ensemble spread is too small and that too many observations fall outside the extremes of the ensemble while a âˆ©-shaped diagram mean the spread too larage and too many observations falling near the center of the ensemble.\n\nExample\n\nusing PyPlot, DataAssim\nNens = 100\nNsample = 10000\n# Ensemble\nx = randn(Nsample,Nens)\n# Observation\ny = randn(Nsample)\n\nfreq = DataAssim.talagrand_diagram(x,y)\nplot(freq)\nplot(ones(size(freq)) / size(freq,1))\nylim(0,ylim()[2])\nxlabel(\"bins\")\nylabel(\"frequency\")\n\n\n\n\n\n","category":"function"}]
}
