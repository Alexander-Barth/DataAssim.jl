<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>DataAssim.jl · DataAssim</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>DataAssim</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>DataAssim.jl</a><ul class="internal"><li><a class="tocitem" href="#Simulation-driver"><span>Simulation driver</span></a></li><li><a class="tocitem" href="#Ensemble-methods"><span>Ensemble methods</span></a></li><li><a class="tocitem" href="#Models"><span>Models</span></a></li><li><a class="tocitem" href="#Utility-functions"><span>Utility functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>DataAssim.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>DataAssim.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="DataAssim.jl"><a class="docs-heading-anchor" href="#DataAssim.jl">DataAssim.jl</a><a id="DataAssim.jl-1"></a><a class="docs-heading-anchor-permalink" href="#DataAssim.jl" title="Permalink"></a></h1><p>Documentation for <a href="https://github.com/Alexander-Barth/DataAssim.jl">DataAssim.jl</a></p><h2 id="Simulation-driver"><a class="docs-heading-anchor" href="#Simulation-driver">Simulation driver</a><a id="Simulation-driver-1"></a><a class="docs-heading-anchor-permalink" href="#Simulation-driver" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataAssim.FreeRun" href="#DataAssim.FreeRun"><code>DataAssim.FreeRun</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">x,Hx = FreeRun(ℳ,xi,Q,H,nmax,no)</code></pre><p>Performs a free-run with the model <code>ℳ</code> and <code>nmax</code> time-steps starting at the initial condition <code>xi</code>. Observations at the time steps given in <code>no</code> are extracted with the observation operator <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/cc52e15f6ba6d5deb0f1d18f2b447930850dda27/src/fourDVar.jl#L22-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssim.KalmanFilter" href="#DataAssim.KalmanFilter"><code>DataAssim.KalmanFilter</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">x,P = KalmanFilter(xi,Pi,ℳ,Q,yo,R,H,nmax,no)</code></pre><p>Kalman Filter with the model <code>ℳ</code> and <code>nmax</code> time-steps starting at the initial condition <code>xi</code> and error covariance <code>Pi</code>. Observations <code>yo</code> (and error covariance <code>R</code>) at the time steps given in <code>no</code> are assimilated with the observation operator <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/cc52e15f6ba6d5deb0f1d18f2b447930850dda27/src/KalmanFilter.jl#L5-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssim.fourDVar" href="#DataAssim.fourDVar"><code>DataAssim.fourDVar</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">x,J = fourDVar(
        xi,Pi,ℳ,yo,R,H,nmax,no;
        innerloops = 10,
        outerloops = 2,
        tol = 1e-5)</code></pre><p>Incremental 4D-Var with the model <code>ℳ</code> and <code>nmax</code> time-steps starting at the initial condition <code>xi</code> and error covariance <code>Pi</code> with the specified numbers of inner and outer loops. Observations <code>yo</code> (and error covariance <code>R</code>) at the time steps given in <code>no</code> are assimilated with the observation operator <code>H</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/cc52e15f6ba6d5deb0f1d18f2b447930850dda27/src/fourDVar.jl#L79-L91">source</a></section></article><h2 id="Ensemble-methods"><a class="docs-heading-anchor" href="#Ensemble-methods">Ensemble methods</a><a id="Ensemble-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Ensemble-methods" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataAssim.ETKF" href="#DataAssim.ETKF"><code>DataAssim.ETKF</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Xa,xa = ETKF(Xf,HXf,y,R,H,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> and observations <code>y</code> using the ETKF ensemble scheme.</p><p><strong>Input arguments:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>HXf</code>: the observation operator applied on the ensemble (product H*Xf)</li><li><code>y</code>: observations (m)</li><li><code>R</code>: observation error covariance  (m x m).</li><li><code>H</code>: operator (m x n). Except for the serialEnSRF it is never used and can be empty</li></ul><p><strong>Optional keywords arguments:</strong></p><ul><li><code>debug</code>: set to true to enable debugging. Default (false) is no debugging.</li><li><code>tolerance</code>: expected rounding error (default 1e-10) for debugging checks. This is not used if debug is false.</li></ul><p><strong>Output arguments:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>: the analysis ensemble mean (n)</li></ul><p>Notations follows: Sangoma D3.1 http://data-assimilation.net/Documents/sangomaDL3.1.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/cc52e15f6ba6d5deb0f1d18f2b447930850dda27/src/ensemble.jl#L8-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssim.EnKF" href="#DataAssim.EnKF"><code>DataAssim.EnKF</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Xa,xa = EnKF(Xf,HXf,y,R,H,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> and observations <code>y</code> using the EnKF ensemble scheme.</p><p><strong>Input arguments:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>HXf</code>: the observation operator applied on the ensemble (product H*Xf)</li><li><code>y</code>: observations (m)</li><li><code>R</code>: observation error covariance  (m x m).</li><li><code>H</code>: operator (m x n). Except for the serialEnSRF it is never used and can be empty</li></ul><p><strong>Optional keywords arguments:</strong></p><ul><li><code>debug</code>: set to true to enable debugging. Default (false) is no debugging.</li><li><code>tolerance</code>: expected rounding error (default 1e-10) for debugging checks. This is not used if debug is false.</li></ul><p><strong>Output arguments:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>: the analysis ensemble mean (n)</li></ul><p>Notations follows: Sangoma D3.1 http://data-assimilation.net/Documents/sangomaDL3.1.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/cc52e15f6ba6d5deb0f1d18f2b447930850dda27/src/ensemble.jl#L8-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssim.EnSRF" href="#DataAssim.EnSRF"><code>DataAssim.EnSRF</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Xa,xa = EnSRF(Xf,HXf,y,R,H,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> and observations <code>y</code> using the EnSRF ensemble scheme.</p><p><strong>Input arguments:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>HXf</code>: the observation operator applied on the ensemble (product H*Xf)</li><li><code>y</code>: observations (m)</li><li><code>R</code>: observation error covariance  (m x m).</li><li><code>H</code>: operator (m x n). Except for the serialEnSRF it is never used and can be empty</li></ul><p><strong>Optional keywords arguments:</strong></p><ul><li><code>debug</code>: set to true to enable debugging. Default (false) is no debugging.</li><li><code>tolerance</code>: expected rounding error (default 1e-10) for debugging checks. This is not used if debug is false.</li></ul><p><strong>Output arguments:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>: the analysis ensemble mean (n)</li></ul><p>Notations follows: Sangoma D3.1 http://data-assimilation.net/Documents/sangomaDL3.1.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/cc52e15f6ba6d5deb0f1d18f2b447930850dda27/src/ensemble.jl#L8-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssim.EAKF" href="#DataAssim.EAKF"><code>DataAssim.EAKF</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Xa,xa = EAKF(Xf,HXf,y,R,H,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> and observations <code>y</code> using the EAKF ensemble scheme.</p><p><strong>Input arguments:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>HXf</code>: the observation operator applied on the ensemble (product H*Xf)</li><li><code>y</code>: observations (m)</li><li><code>R</code>: observation error covariance  (m x m).</li><li><code>H</code>: operator (m x n). Except for the serialEnSRF it is never used and can be empty</li></ul><p><strong>Optional keywords arguments:</strong></p><ul><li><code>debug</code>: set to true to enable debugging. Default (false) is no debugging.</li><li><code>tolerance</code>: expected rounding error (default 1e-10) for debugging checks. This is not used if debug is false.</li></ul><p><strong>Output arguments:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>: the analysis ensemble mean (n)</li></ul><p>Notations follows: Sangoma D3.1 http://data-assimilation.net/Documents/sangomaDL3.1.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/cc52e15f6ba6d5deb0f1d18f2b447930850dda27/src/ensemble.jl#L8-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssim.SEIK" href="#DataAssim.SEIK"><code>DataAssim.SEIK</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Xa,xa = SEIK(Xf,HXf,y,R,H,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> and observations <code>y</code> using the SEIK ensemble scheme.</p><p><strong>Input arguments:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>HXf</code>: the observation operator applied on the ensemble (product H*Xf)</li><li><code>y</code>: observations (m)</li><li><code>R</code>: observation error covariance  (m x m).</li><li><code>H</code>: operator (m x n). Except for the serialEnSRF it is never used and can be empty</li></ul><p><strong>Optional keywords arguments:</strong></p><ul><li><code>debug</code>: set to true to enable debugging. Default (false) is no debugging.</li><li><code>tolerance</code>: expected rounding error (default 1e-10) for debugging checks. This is not used if debug is false.</li></ul><p><strong>Output arguments:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>: the analysis ensemble mean (n)</li></ul><p>Notations follows: Sangoma D3.1 http://data-assimilation.net/Documents/sangomaDL3.1.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/cc52e15f6ba6d5deb0f1d18f2b447930850dda27/src/ensemble.jl#L8-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssim.ESTKF" href="#DataAssim.ESTKF"><code>DataAssim.ESTKF</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Xa,xa = ESTKF(Xf,HXf,y,R,H,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> and observations <code>y</code> using the ESTKF ensemble scheme.</p><p><strong>Input arguments:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>HXf</code>: the observation operator applied on the ensemble (product H*Xf)</li><li><code>y</code>: observations (m)</li><li><code>R</code>: observation error covariance  (m x m).</li><li><code>H</code>: operator (m x n). Except for the serialEnSRF it is never used and can be empty</li></ul><p><strong>Optional keywords arguments:</strong></p><ul><li><code>debug</code>: set to true to enable debugging. Default (false) is no debugging.</li><li><code>tolerance</code>: expected rounding error (default 1e-10) for debugging checks. This is not used if debug is false.</li></ul><p><strong>Output arguments:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>: the analysis ensemble mean (n)</li></ul><p>Notations follows: Sangoma D3.1 http://data-assimilation.net/Documents/sangomaDL3.1.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/cc52e15f6ba6d5deb0f1d18f2b447930850dda27/src/ensemble.jl#L8-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssim.serialEnSRF" href="#DataAssim.serialEnSRF"><code>DataAssim.serialEnSRF</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Xa,xa = serialEnSRF(Xf,HXf,y,R,H,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> and observations <code>y</code> using the serialEnSRF ensemble scheme.</p><p><strong>Input arguments:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>HXf</code>: the observation operator applied on the ensemble (product H*Xf)</li><li><code>y</code>: observations (m)</li><li><code>R</code>: observation error covariance  (m x m).</li><li><code>H</code>: operator (m x n). Except for the serialEnSRF it is never used and can be empty</li></ul><p><strong>Optional keywords arguments:</strong></p><ul><li><code>debug</code>: set to true to enable debugging. Default (false) is no debugging.</li><li><code>tolerance</code>: expected rounding error (default 1e-10) for debugging checks. This is not used if debug is false.</li></ul><p><strong>Output arguments:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>: the analysis ensemble mean (n)</li></ul><p>Notations follows: Sangoma D3.1 http://data-assimilation.net/Documents/sangomaDL3.1.pdf</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/cc52e15f6ba6d5deb0f1d18f2b447930850dda27/src/ensemble.jl#L8-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssim.local_ETKF" href="#DataAssim.local_ETKF"><code>DataAssim.local_ETKF</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Xa,xa = local_ETKF(Xf,H,y,diagR,part,selectObs,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> using the observation <code>y</code> using the local ETKF.</p><p><strong>Inputs:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>H</code>: observation operator (m x n)</li><li><code>y</code>: observation (m x 1)</li><li><code>diagR</code>: diagonal of the observation error covariance R (m x 1)</li><li><code>part</code>: vector of integer &quot;labels&quot;. Every element of the state vector with the same number belong to the same subdomain</li><li><code>selectObs</code>: callback routine to select observations with a within a subdomain. As input is takes an integer representing the index of the state vector and returns a vector of weights (m x 1). For example:</li></ul><pre><code class="nohighlight hljs">     selectObs(i) = exp(- ((x[i] - xobs[:]).^2 + (y(i) - yobs[:]).^2)/L^2 );</code></pre><p>or</p><pre><code class="nohighlight hljs">     selectObs(i) = compact_locfun(L,...
         sqrt((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2));</code></pre><p>where <code>x</code> and <code>y</code> is the horizontal model grid, <code>xobs</code> and <code>yobs</code> are the locations of the observations and <code>L</code> is a correlation length-scale</p><p><strong>Optional inputs:</strong></p><ul><li><code>display</code>: if true, then display progress (false is the default)</li><li><code>minweight</code>: analysis is performed using observations for which  weights is larger than minweight. (default 1e-8)</li><li><code>HXf</code>: if non empty, then it is the product <code>H*Xf</code>. In this case, <code>H</code> is not  used</li></ul><p><strong>Output:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>`: the analysis ensemble mean (n x 1)</li></ul><p>See also: compact_locfun</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/cc52e15f6ba6d5deb0f1d18f2b447930850dda27/src/ensemble.jl#L364-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssim.local_EnKF" href="#DataAssim.local_EnKF"><code>DataAssim.local_EnKF</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Xa,xa = local_EnKF(Xf,H,y,diagR,part,selectObs,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> using the observation <code>y</code> using the local EnKF.</p><p><strong>Inputs:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>H</code>: observation operator (m x n)</li><li><code>y</code>: observation (m x 1)</li><li><code>diagR</code>: diagonal of the observation error covariance R (m x 1)</li><li><code>part</code>: vector of integer &quot;labels&quot;. Every element of the state vector with the same number belong to the same subdomain</li><li><code>selectObs</code>: callback routine to select observations with a within a subdomain. As input is takes an integer representing the index of the state vector and returns a vector of weights (m x 1). For example:</li></ul><pre><code class="nohighlight hljs">     selectObs(i) = exp(- ((x[i] - xobs[:]).^2 + (y(i) - yobs[:]).^2)/L^2 );</code></pre><p>or</p><pre><code class="nohighlight hljs">     selectObs(i) = compact_locfun(L,...
         sqrt((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2));</code></pre><p>where <code>x</code> and <code>y</code> is the horizontal model grid, <code>xobs</code> and <code>yobs</code> are the locations of the observations and <code>L</code> is a correlation length-scale</p><p><strong>Optional inputs:</strong></p><ul><li><code>display</code>: if true, then display progress (false is the default)</li><li><code>minweight</code>: analysis is performed using observations for which  weights is larger than minweight. (default 1e-8)</li><li><code>HXf</code>: if non empty, then it is the product <code>H*Xf</code>. In this case, <code>H</code> is not  used</li></ul><p><strong>Output:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>`: the analysis ensemble mean (n x 1)</li></ul><p>See also: compact_locfun</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/cc52e15f6ba6d5deb0f1d18f2b447930850dda27/src/ensemble.jl#L364-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssim.local_EnSRF" href="#DataAssim.local_EnSRF"><code>DataAssim.local_EnSRF</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Xa,xa = local_EnSRF(Xf,H,y,diagR,part,selectObs,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> using the observation <code>y</code> using the local EnSRF.</p><p><strong>Inputs:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>H</code>: observation operator (m x n)</li><li><code>y</code>: observation (m x 1)</li><li><code>diagR</code>: diagonal of the observation error covariance R (m x 1)</li><li><code>part</code>: vector of integer &quot;labels&quot;. Every element of the state vector with the same number belong to the same subdomain</li><li><code>selectObs</code>: callback routine to select observations with a within a subdomain. As input is takes an integer representing the index of the state vector and returns a vector of weights (m x 1). For example:</li></ul><pre><code class="nohighlight hljs">     selectObs(i) = exp(- ((x[i] - xobs[:]).^2 + (y(i) - yobs[:]).^2)/L^2 );</code></pre><p>or</p><pre><code class="nohighlight hljs">     selectObs(i) = compact_locfun(L,...
         sqrt((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2));</code></pre><p>where <code>x</code> and <code>y</code> is the horizontal model grid, <code>xobs</code> and <code>yobs</code> are the locations of the observations and <code>L</code> is a correlation length-scale</p><p><strong>Optional inputs:</strong></p><ul><li><code>display</code>: if true, then display progress (false is the default)</li><li><code>minweight</code>: analysis is performed using observations for which  weights is larger than minweight. (default 1e-8)</li><li><code>HXf</code>: if non empty, then it is the product <code>H*Xf</code>. In this case, <code>H</code> is not  used</li></ul><p><strong>Output:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>`: the analysis ensemble mean (n x 1)</li></ul><p>See also: compact_locfun</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/cc52e15f6ba6d5deb0f1d18f2b447930850dda27/src/ensemble.jl#L364-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssim.local_EAKF" href="#DataAssim.local_EAKF"><code>DataAssim.local_EAKF</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Xa,xa = local_EAKF(Xf,H,y,diagR,part,selectObs,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> using the observation <code>y</code> using the local EAKF.</p><p><strong>Inputs:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>H</code>: observation operator (m x n)</li><li><code>y</code>: observation (m x 1)</li><li><code>diagR</code>: diagonal of the observation error covariance R (m x 1)</li><li><code>part</code>: vector of integer &quot;labels&quot;. Every element of the state vector with the same number belong to the same subdomain</li><li><code>selectObs</code>: callback routine to select observations with a within a subdomain. As input is takes an integer representing the index of the state vector and returns a vector of weights (m x 1). For example:</li></ul><pre><code class="nohighlight hljs">     selectObs(i) = exp(- ((x[i] - xobs[:]).^2 + (y(i) - yobs[:]).^2)/L^2 );</code></pre><p>or</p><pre><code class="nohighlight hljs">     selectObs(i) = compact_locfun(L,...
         sqrt((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2));</code></pre><p>where <code>x</code> and <code>y</code> is the horizontal model grid, <code>xobs</code> and <code>yobs</code> are the locations of the observations and <code>L</code> is a correlation length-scale</p><p><strong>Optional inputs:</strong></p><ul><li><code>display</code>: if true, then display progress (false is the default)</li><li><code>minweight</code>: analysis is performed using observations for which  weights is larger than minweight. (default 1e-8)</li><li><code>HXf</code>: if non empty, then it is the product <code>H*Xf</code>. In this case, <code>H</code> is not  used</li></ul><p><strong>Output:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>`: the analysis ensemble mean (n x 1)</li></ul><p>See also: compact_locfun</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/cc52e15f6ba6d5deb0f1d18f2b447930850dda27/src/ensemble.jl#L364-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssim.local_SEIK" href="#DataAssim.local_SEIK"><code>DataAssim.local_SEIK</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Xa,xa = local_SEIK(Xf,H,y,diagR,part,selectObs,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> using the observation <code>y</code> using the local SEIK.</p><p><strong>Inputs:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>H</code>: observation operator (m x n)</li><li><code>y</code>: observation (m x 1)</li><li><code>diagR</code>: diagonal of the observation error covariance R (m x 1)</li><li><code>part</code>: vector of integer &quot;labels&quot;. Every element of the state vector with the same number belong to the same subdomain</li><li><code>selectObs</code>: callback routine to select observations with a within a subdomain. As input is takes an integer representing the index of the state vector and returns a vector of weights (m x 1). For example:</li></ul><pre><code class="nohighlight hljs">     selectObs(i) = exp(- ((x[i] - xobs[:]).^2 + (y(i) - yobs[:]).^2)/L^2 );</code></pre><p>or</p><pre><code class="nohighlight hljs">     selectObs(i) = compact_locfun(L,...
         sqrt((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2));</code></pre><p>where <code>x</code> and <code>y</code> is the horizontal model grid, <code>xobs</code> and <code>yobs</code> are the locations of the observations and <code>L</code> is a correlation length-scale</p><p><strong>Optional inputs:</strong></p><ul><li><code>display</code>: if true, then display progress (false is the default)</li><li><code>minweight</code>: analysis is performed using observations for which  weights is larger than minweight. (default 1e-8)</li><li><code>HXf</code>: if non empty, then it is the product <code>H*Xf</code>. In this case, <code>H</code> is not  used</li></ul><p><strong>Output:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>`: the analysis ensemble mean (n x 1)</li></ul><p>See also: compact_locfun</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/cc52e15f6ba6d5deb0f1d18f2b447930850dda27/src/ensemble.jl#L364-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssim.local_ESTKF" href="#DataAssim.local_ESTKF"><code>DataAssim.local_ESTKF</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Xa,xa = local_ESTKF(Xf,H,y,diagR,part,selectObs,...)</p><p>Computes analysis ensemble <code>Xa</code> based on forecast ensemble <code>Xf</code> using the observation <code>y</code> using the local ESTKF.</p><p><strong>Inputs:</strong></p><ul><li><code>Xf</code>: forecast ensemble (n x N)</li><li><code>H</code>: observation operator (m x n)</li><li><code>y</code>: observation (m x 1)</li><li><code>diagR</code>: diagonal of the observation error covariance R (m x 1)</li><li><code>part</code>: vector of integer &quot;labels&quot;. Every element of the state vector with the same number belong to the same subdomain</li><li><code>selectObs</code>: callback routine to select observations with a within a subdomain. As input is takes an integer representing the index of the state vector and returns a vector of weights (m x 1). For example:</li></ul><pre><code class="nohighlight hljs">     selectObs(i) = exp(- ((x[i] - xobs[:]).^2 + (y(i) - yobs[:]).^2)/L^2 );</code></pre><p>or</p><pre><code class="nohighlight hljs">     selectObs(i) = compact_locfun(L,...
         sqrt((x[i] - xobs[:]).^2 + (y[i] - yobs[:]).^2));</code></pre><p>where <code>x</code> and <code>y</code> is the horizontal model grid, <code>xobs</code> and <code>yobs</code> are the locations of the observations and <code>L</code> is a correlation length-scale</p><p><strong>Optional inputs:</strong></p><ul><li><code>display</code>: if true, then display progress (false is the default)</li><li><code>minweight</code>: analysis is performed using observations for which  weights is larger than minweight. (default 1e-8)</li><li><code>HXf</code>: if non empty, then it is the product <code>H*Xf</code>. In this case, <code>H</code> is not  used</li></ul><p><strong>Output:</strong></p><ul><li><code>Xa</code>: the analysis ensemble (n x N)</li><li><code>xa</code>`: the analysis ensemble mean (n x 1)</li></ul><p>See also: compact_locfun</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/cc52e15f6ba6d5deb0f1d18f2b447930850dda27/src/ensemble.jl#L364-L405">source</a></section></article><h2 id="Models"><a class="docs-heading-anchor" href="#Models">Models</a><a id="Models-1"></a><a class="docs-heading-anchor-permalink" href="#Models" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataAssim.AbstractModel" href="#DataAssim.AbstractModel"><code>DataAssim.AbstractModel</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract base-class of models. A model should implement forecast step, tangent-linear and adjoint step</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/cc52e15f6ba6d5deb0f1d18f2b447930850dda27/src/models.jl#L2-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssim.ModelMatrix" href="#DataAssim.ModelMatrix"><code>DataAssim.ModelMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ℳ = ModelMatrix(M)</code></pre><p>Linear model defined by the matrix <code>M</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/cc52e15f6ba6d5deb0f1d18f2b447930850dda27/src/models.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssim.ModelFun" href="#DataAssim.ModelFun"><code>DataAssim.ModelFun</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ℳ = ModelFun(nonlinear_forecast,tangent_linear_model,adjoint_model)</code></pre><p>Model defined by the functions <code>nonlinear_forecast</code>,<code>tangent_linear_model</code> and  <code>adjoint_model</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/cc52e15f6ba6d5deb0f1d18f2b447930850dda27/src/models.jl#L32-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssim.LinShallowWater1DModel" href="#DataAssim.LinShallowWater1DModel"><code>DataAssim.LinShallowWater1DModel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ℳ = LinShallowWater1DModel(dt,g,h,L,imax)</code></pre><p>Linear 1D shallow water model.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">dt = 1.
g = 9.81
h = 100
imax = 101
L = 10000
LinShallowWater1DModel(dt,g,h,L,imax)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/cc52e15f6ba6d5deb0f1d18f2b447930850dda27/src/shallow_water1D_model.jl#L18-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="DataAssim.Lorenz63Model" href="#DataAssim.Lorenz63Model"><code>DataAssim.Lorenz63Model</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ℳ = Lorenz63Model(dt,σ=10.,β = 8/3.,ρ = 28.)</code></pre><p>Lorenz, 1963 model[1] integrated with a 2nd order Runge-Kutta scheme.</p><p>[1] https://doi.org/10.1175/1520-0469(1963)020%3C0130:DNF%3E2.0.CO;2</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/cc52e15f6ba6d5deb0f1d18f2b447930850dda27/src/lorenz63model.jl#L9-L15">source</a></section></article><h2 id="Utility-functions"><a class="docs-heading-anchor" href="#Utility-functions">Utility functions</a><a id="Utility-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="DataAssim.compact_locfun" href="#DataAssim.compact_locfun"><code>DataAssim.compact_locfun</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs"> fun = compact_locfun(r)</code></pre><p>Smooth compact localization function at the (scaled) distance <code>r</code>. <code>fun</code> is zero if <code>r</code> &gt; 2 and one if <code>r</code> is 0. (Gaspari et al. (1999), equation 4.10, [1])</p><p>[1] http://dx.doi.org/10.1002/qj.49712555417</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Alexander-Barth/DataAssim.jl/blob/cc52e15f6ba6d5deb0f1d18f2b447930850dda27/src/ensemble.jl#L464-L472">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Sunday 19 June 2022 20:39">Sunday 19 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
